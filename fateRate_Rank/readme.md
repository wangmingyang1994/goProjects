作业说明：\
模型抽象\
1.用户 属性：1）姓名 2）体脂率 3）用户ID\
2.排行榜 属性：1）用户排行榜【用户的slice】 2）sync.Mutex或channel

排行榜功能分两块实现\
1.将用户插入排行榜\
1）用户初始化时只赋值姓名和体脂率；排行榜人数自增，并将其作为用户ID赋给要插入的用户\
2）排行榜插入用户方法的实现：\
    1⃣️判断用户的体脂率是否符合规范(0-0.4)，若符合，则将用户追加到排行榜中，否则输出报错并结束程序\
    2⃣️将用户追加到排行榜榜尾\
    3⃣️重新将排行榜按每个用户的体脂率从小到大的顺序排序\
    4⃣️遍历排行榜，查询刚插入用户的下标，将其加1作为排名返回\

2.按用户ID搜索到用户，更改其体脂率并重新排序\
1）判断用户的体脂率是否符合规范(0-0.4)，若符合，则进行下一步，否则输入报错并结束程序\
2）遍历排行榜，根据ID定位到要更改体脂率的用户
3）更改其体脂率
4）重新将排行榜按每个用户的体脂率从小到大的顺序排序\
5）遍历排行榜，查询刚插入用户的下标，将其加1作为排名返回\

其他细节：\
1）更新用户的体脂率，先设置时间为rand包的种子，
循环，获取一个float64的随机数，若其在0-0.2之间， 则将其作为浮动体脂数；
然后获取要更新的用户的体脂率；此时再获取一个0-10的随机数，若随机数是偶数，则将原体脂率加浮动的体脂数，
否则将原体脂率减去该浮动体脂数，获得一个新的体脂率；判断是否符合体脂率标准，若符合，则将其更新，否则继续下
一次循环，直至将体脂率更新
2）更新用户体脂率时，使用range循环（for i,v:=range slice）按ID查询用户，找到用户时，直接更新用户的体脂率（v.FateRate=newFateRate），
发现不生效，最后改为使用下标循环（for i:=0;i<n;i++），最终更改（slice[i].FateRate=newFateRate）成功了



A.查看1000人插入排行榜和更新排行榜的效果（因写入死循环，自测时发现必须使用goland运行）\
切换到目录：fateRate_Rank/rankOfFateRate_channel\
运行函数：TestRankOfFateRate

或
切换到目录：fateRate_Rank/rankOfFateRate_sync\
运行函数：TestRankOfFateRate

B.查看单用户插入排行榜和更新排行榜的效果\
（插入两个用户：用户2的体脂率大于用户1，则排名为：用户1，用户2；\
更新用户2的体脂率更新为比用户1小的体脂率，此时用户2 的排名为1，总排名为：用户2，用户1）\
cd fateRate_Rank/rankOfFateRate_channel\
go run channelRank.go

或
cd fateRate_Rank/rankOfFateRate_sync\
go run syncRank.go 